// cSpell:dictionaries python
{
  "assert statement": {
    "body": "assert $1, f\"$1: {$1}\"",
    "description": "assert statement",
    "prefix": "ass"
  },
  "async define function": {
    "body": "async def ${1:$TM_FILENAME_BASE}($2):\n\t${0:pass}",
    "description": "async define function",
    "prefix": "adf"
  },
  "async for it in ait": {
    "body": "async for ${1:it} in $2:\n\t${0:pass}",
    "description": "async for it in ait",
    "prefix": "afi"
  },
  "cast": {
    "body": "cast(${1:int}, $TM_SELECTED_TEXT)",
    "description": "cast",
    "prefix": "cas"
  },
  "class": {
    "body": "class ${1:$TM_FILENAME_BASE}:\n\t${0:pass}",
    "description": "class",
    "prefix": "cla"
  },
  "classmethod": {
    "body": "@classmethod\ndef $1(cls$1):\n\t${0:pass}",
    "description": "classmethod",
    "prefix": "clm"
  },
  "cls": {
    "body": "cls.",
    "description": "cls",
    "prefix": "c"
  },
  "comprehension": {
    "body": "${3:$1} for ${1:i} in ${2:range()}${1/.+?(,).+?/${0:?.items(): }/}",
    "description": "comprehension",
    "prefix": "comp"
  },
  "def __init__(self)": {
    "body": "def __init__(self$1):\n\t${0:pass}",
    "description": "def __init__(self)",
    "prefix": "_init_"
  },
  "define function": {
    "body": "def $1($2):\n\t${0:pass}",
    "description": "define function",
    "prefix": "df"
  },
  "dict keys": {
    "body": "'$1': '${2:$1}',",
    "description": "dict keys",
    "prefix": "k"
  },
  "for i in range": {
    "body": "for ${1:i} in range($2):\n\t${0:pass}",
    "description": "for i in range",
    "prefix": "fri"
  },
  "for i in range len": {
    "body": "for ${1:i} in range(len($2)):\n\t${0:pass}",
    "description": "for i in range len",
    "prefix": "frl"
  },
  "for i in range len reversed": {
    "body": "for ${1:i} in range(len($2) - 1, -1, -1):\n\t${0:pass}",
    "description": "for i in range len reversed",
    "prefix": "frlr"
  },
  "for i in range reversed": {
    "body": "for ${1:i} in range($2, -1, -1):\n\t${0:pass}",
    "description": "for i in range reversed",
    "prefix": "frr"
  },
  "for i, val in enumerate()": {
    "body": "for ${1:i}, ${2:val} in enumerate($3):\n\t${0:pass}",
    "description": "for i, val in enumerate()",
    "prefix": "fine"
  },
  "for it in iterator": {
    "body": "for ${1:it} in $2:\n\t${0:pass}",
    "description": "for it in iterator",
    "prefix": "fin"
  },
  "for key, val in dict.items()": {
    "body": "for ${1:key}, ${2:val} in $3.items():\n\t${0:pass}",
    "description": "for key, val in dict.items()",
    "prefix": "find"
  },
  "for val1, val2 in zip(iter1, iter2)": {
    "body": "for ${1:val1}, ${2:val2} in zip($3, $4):\n\t${0:pass}",
    "description": "for val1, val2 in zip(iter1, iter2)",
    "prefix": "finz"
  },
  "from os import path": {
    "body": "from ${1:os} import ${0:path}",
    "description": "from os import path",
    "prefix": "fim"
  },
  "from os.path import join as path_join": {
    "body": "from ${1:os.path} import ${2:join} as ${0:path_join}",
    "description": "from os.path import join as path_join",
    "prefix": "fima"
  },
  "if __name__ == '__main__'": {
    "body": "if __name__ == '__main__':\n\t${0:pass}",
    "description": "if __name__ == '__main__'",
    "prefix": "ifmain"
  },
  "if is None": {
    "body": "if ${1:$TM_SELECTED_TEXT} is None:\n\t${0:pass}",
    "description": "if is None",
    "prefix": "ifin"
  },
  "if is not None": {
    "body": "if ${1:$TM_SELECTED_TEXT} is not None:\n\t${0:pass}",
    "description": "if is not None",
    "prefix": "ifnn"
  },
  "if not": {
    "body": "if not ${1:$TM_SELECTED_TEXT}:\n\t${0:pass}",
    "description": "if not",
    "prefix": "ifn"
  },
  "import numpy as np": {
    "body": "import ${1:numpy} as ${0:np}",
    "description": "import numpy as np",
    "prefix": "ima"
  },
  "Lambda Expression": {
    "body": "lambda $1: ",
    "description": "Lambda Expression",
    "prefix": "l"
  },
  "next operation": {
    "body": "$1 = ${1/\\w+/$0${0:+.next}/g}",
    "description": "next operation",
    "prefix": "nop"
  },
  "property (with setter)": {
    "body": [
      "@property",
      "def $1(self):",
      "\t${0:return self._$1}",
      "",
      "@$1.setter",
      "def $1(self, value):",
      "\tself._$1 = value",
      ""
    ],
    "description": "property (with setter)",
    "prefix": "prop"
  },
  "property with setter and deleter": {
    "body": [
      "@property",
      "def $2(self):",
      "\t${0:return self._$2}",
      "",
      "@$2.setter",
      "def $2(self, value):",
      "\tself._$2 = value",
      "",
      "@$2.deleter",
      "def $2(self):",
      "\tdel self._$2",
      ""
    ],
    "description": "property with setter and deleter",
    "prefix": "psd"
  },
  "Python File Doc": {
    "body": [
      "#!/usr/bin/env python3",
      "'''",
      "Description: ${1:None}",
      "File: $TM_FILENAME",
      "Time: $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
      "Authors: (Ming.Chen https://github.com/xingqingxyz cm.email@qq.com)",
      "'''",
      ""
    ],
    "description": "Python File Doc",
    "isFileTemplate": true,
    "prefix": "!doc"
  },
  "Quote Comma": {
    "body": "'$1',",
    "description": "Quote Comma",
    "prefix": "q"
  },
  "staticmethod": {
    "body": "@staticmethod\ndef $1($2):\n\t${0:pass}",
    "description": "staticmethod",
    "prefix": "sm"
  },
  "super().__init__(self)": {
    "body": "super().__init__(self, $1)",
    "description": "super().__init__(self)",
    "prefix": "_super_"
  },
  "Ternary Expression": {
    "body": "(${1:$TM_SELECTED_TEXT} if $2 else $3)",
    "description": "Ternary Expression",
    "prefix": "ter"
  },
  "try-except": {
    "body": [
      "try:",
      "\t${1:$TM_SELECTED_TEXT}",
      "except ${2:Exception} as err:",
      "\t${0:pass}"
    ],
    "description": "try-except",
    "prefix": "tre"
  },
  "try-except-else": {
    "body": [
      "try:",
      "\t${1:$TM_SELECTED_TEXT}",
      "except ${2:Exception} as err:",
      "\t${0:pass}",
      "else:",
      "\t${2:pass}"
    ],
    "description": "try-except-else",
    "prefix": "tree"
  },
  "try-except-else-finally(try-all)": {
    "body": [
      "try:",
      "\t${1:$TM_SELECTED_TEXT}",
      "except ${2:Exception} as err:",
      "\t${0:pass}",
      "else:",
      "\tpass",
      "finally:",
      "\t${2:pass}"
    ],
    "description": "try-except-else-finally(try-all)",
    "prefix": "tra"
  },
  "try-except-finally": {
    "body": [
      "try:",
      "\t${1:$TM_SELECTED_TEXT}",
      "except ${2:Exception} as err:",
      "\t${0:pass}",
      "finally:",
      "\t${2:pass}"
    ],
    "description": "try-except-finally",
    "prefix": "tref"
  },
  "try-finally": {
    "body": "try:\n\t${1:$TM_SELECTED_TEXT}\nfinally:\n\t${0:pass}",
    "description": "try-finally",
    "prefix": "trf"
  },
  "Walrus Operator": {
    "body": "($1 := $TM_SELECTED_TEXT)",
    "description": "Walrus Operator",
    "prefix": "wal"
  },
  "while loop": {
    "body": "while ${1:True}:\n\t${0:pass}",
    "description": "while loop",
    "prefix": "wh"
  },
  "with open(file) as f": {
    "body": "${1|with open,async with aiofiles.open|}($2, '${3|r,w,a,r+,w+,a+,rb,wb,ab,rb+,wb+,ab+|}'${3/[rwa](b?)\\+?/${1:?):, encoding='utf-8')}/} as f:\n\t${0:pass}",
    "description": "with open(file) as f",
    "prefix": "wop"
  }
}
